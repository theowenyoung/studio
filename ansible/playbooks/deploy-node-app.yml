---
# =====================================
# Node.js 应用部署
# 本地构建 + ECR + 服务器拉取部署
# =====================================
- name: Deploy Node.js Application
  hosts: localhost
  gather_facts: no
  become: no

  vars:
    app_name: "{{ app }}"
    aws_region: "{{ region | default('us-west-2') }}"
    ecr_registry: "912951144733.dkr.ecr.us-west-2.amazonaws.com"
    image_tag: "{{ tag | default('latest') }}"

  tasks:
    - name: 验证应用名称
      fail:
        msg: "请指定应用名称: --extra-vars app=node-demo"
      when: app_name is not defined or app_name == ""

    - name: 显示构建信息
      debug:
        msg:
          - "=== Node.js 应用本地构建 ==="
          - "应用名称: {{ app_name }}"
          - "ECR Registry: {{ ecr_registry }}"
          - "镜像标签: {{ image_tag }}"
          - "AWS 区域: {{ aws_region }}"
          - "========================="

    - name: 检查应用目录是否存在
      stat:
        path: "{{ playbook_dir }}/../../js-apps/{{ app_name }}"
      register: app_dir

    - name: 验证应用目录存在
      fail:
        msg: "应用目录不存在: js-apps/{{ app_name }}"
      when: not app_dir.stat.exists

    - name: 登录 ECR
      shell: |
        aws ecr get-login-password --region {{ aws_region }} | \
        docker login --username AWS --password-stdin {{ ecr_registry }}
      args:
        chdir: "{{ playbook_dir }}/../../js-apps/{{ app_name }}"

    - name: 构建 Docker 镜像 (linux/amd64)
      shell: |
        docker build --platform linux/amd64 \
          -t {{ app_name }}:{{ image_tag }} \
          -t {{ ecr_registry }}/{{ app_name }}:{{ image_tag }} .
      args:
        chdir: "{{ playbook_dir }}/../../js-apps/{{ app_name }}"

    - name: 推送镜像到 ECR
      shell: docker push {{ ecr_registry }}/{{ app_name }}:{{ image_tag }}
      args:
        chdir: "{{ playbook_dir }}/../../js-apps/{{ app_name }}"

    - name: 显示构建完成信息
      debug:
        msg:
          - "=== 本地构建完成 ==="
          - "镜像: {{ ecr_registry }}/{{ app_name }}:{{ image_tag }}"
          - "开始服务器部署..."

# =====================================
# 服务器部署阶段
# =====================================
- name: Deploy to Server
  hosts: all
  gather_facts: yes
  become: yes

  vars:
    app_name: "{{ app }}"
    deploy_user: "{{ user | default('deploy') }}"
    aws_region: "{{ region | default('us-west-2') }}"
    ecr_registry: "912951144733.dkr.ecr.us-west-2.amazonaws.com"
    image_tag: "{{ tag | default('latest') }}"

  tasks:
    - name: 显示服务器部署信息
      debug:
        msg:
          - "=== 服务器部署阶段 ==="
          - "服务器: {{ inventory_hostname }}"
          - "应用名称: {{ app_name }}"
          - "部署用户: {{ deploy_user }}"
          - "镜像: {{ ecr_registry }}/{{ app_name }}:{{ image_tag }}"
          - "========================="

    - name: 确保共享网络存在
      command: docker network create shared_network
      failed_when: false
      become_user: "{{ deploy_user }}"

    - name: 获取本地 AWS 凭证
      local_action: "shell aws configure get aws_access_key_id && aws configure get aws_secret_access_key"
      register: aws_credentials
      run_once: true
      become: no

    - name: 创建部署目录
      file:
        path: "/opt/{{ app_name }}"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0755'

    - name: 复制 docker-compose 配置到服务器
      copy:
        src: "{{ playbook_dir }}/../../js-apps/{{ app_name }}/docker-compose.prod.yml"
        dest: "/opt/{{ app_name }}/docker-compose.yml"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0644'

    - name: 更新 docker-compose 使用 ECR 镜像
      replace:
        path: "/opt/{{ app_name }}/docker-compose.yml"
        regexp: 'image:\s*{{ app_name }}:latest'
        replace: 'image: {{ ecr_registry }}/{{ app_name }}:{{ image_tag }}'
      become_user: "{{ deploy_user }}"

    - name: 从 AWS Parameter Store 获取环境变量
      shell: |
        export AWS_ACCESS_KEY_ID={{ aws_credentials.stdout_lines[0] }}
        export AWS_SECRET_ACCESS_KEY={{ aws_credentials.stdout_lines[1] }}
        export AWS_REGION={{ aws_region }}
        aws ssm get-parameter --name "/{{ app_name }}/prod/.env" --with-decryption --region {{ aws_region }} --query 'Parameter.Value' --output text
      register: param_store_env
      become_user: "{{ deploy_user }}"

    - name: 创建环境变量文件
      copy:
        content: "{{ param_store_env.stdout }}"
        dest: "/opt/{{ app_name }}/.env"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0600'

    - name: 登录 ECR 并拉取最新镜像
      shell: |
        export AWS_ACCESS_KEY_ID={{ aws_credentials.stdout_lines[0] }}
        export AWS_SECRET_ACCESS_KEY={{ aws_credentials.stdout_lines[1] }}
        export AWS_REGION={{ aws_region }}
        aws ecr get-login-password --region {{ aws_region }} | \
        docker login --username AWS --password-stdin {{ ecr_registry }}
        docker pull {{ ecr_registry }}/{{ app_name }}:{{ image_tag }}
      become_user: "{{ deploy_user }}"

    - name: 停止旧服务
      shell: docker compose down || true
      args:
        chdir: "/opt/{{ app_name }}"
      become_user: "{{ deploy_user }}"
      ignore_errors: yes

    - name: 启动服务
      shell: docker compose up -d
      args:
        chdir: "/opt/{{ app_name }}"
      become_user: "{{ deploy_user }}"
      register: deploy_result

    - name: 等待服务启动
      pause:
        seconds: 10

    - name: 健康检查
      uri:
        url: "http://{{ inventory_hostname }}:3000/health"
        method: GET
        timeout: 5
      register: health_check
      retries: 5
      delay: 5
      ignore_errors: yes

    - name: 显示部署结果
      debug:
        msg:
          - "=== 部署完成 ==="
          - "应用: {{ app_name }}"
          - "状态: {{ 'SUCCESS' if health_check.status == 200 else 'FAILED' }}"
          - "访问地址: http://{{ inventory_hostname }}:3000"
          - "健康检查: {{ 'PASS' if health_check.status == 200 else 'FAIL' }}"

    - name: 部署失败时显示日志
      shell: docker compose logs --tail=50
      args:
        chdir: "/opt/{{ app_name }}"
      become_user: "{{ deploy_user }}"
      when: health_check.status != 200
      ignore_errors: yes
      register: error_logs

    - name: 输出错误日志
      debug:
        msg: "{{ error_logs.stdout_lines }}"
      when: health_check.status != 200
