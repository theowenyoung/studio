---
- name: Deploy Application Service
  hosts: all
  become: yes
  become_user: deploy
  gather_facts: no

  vars:
    service_name: "{{ service_name }}"
    local_dist: "{{ playbook_dir }}/../../js-apps/{{ service_name }}/deploy-dist"
    remote_base: "/srv/studio/js-apps/{{ service_name }}"

  tasks:
    - name: Read version
      slurp:
        src: "{{ local_dist }}/version.txt"
      delegate_to: localhost
      become: no  # Âú®Êú¨Âú∞ËØªÂèñÊñá‰ª∂Ôºå‰∏çÈúÄË¶Å become
      register: version_file

    - name: Set version
      set_fact:
        version: "{{ version_file.content | b64decode | trim }}"

    - debug:
        msg: "üöÄ Deploying {{ service_name }} version {{ version }}"

    - name: Ensure /srv/studio base directory exists
      file:
        path: /srv/studio
        state: directory
        owner: "{{ deploy_user | default('deploy') }}"
        group: "{{ deploy_user | default('deploy') }}"
        mode: '0755'
      become_user: root

    - name: Ensure service base directory exists
      file:
        path: "{{ remote_base }}"
        state: directory
        mode: '0755'

    - name: Create version directory
      file:
        path: "{{ remote_base }}/{{ version }}"
        state: directory
        mode: '0755'

    - name: Sync files
      synchronize:
        src: "{{ local_dist }}/"
        dest: "{{ remote_base }}/{{ version }}/"
        delete: no
        rsync_opts:
          - "--exclude=.git"

    - name: Get previous version (for rollback)
      shell: |
        cd {{ remote_base }}
        if [ -L current ]; then
          readlink current | xargs basename
        fi
      register: previous_version_result
      failed_when: false
      changed_when: false

    - name: Set previous version fact
      set_fact:
        previous_version: "{{ previous_version_result.stdout | default('') }}"

    - name: Update current symlink
      file:
        src: "{{ remote_base }}/{{ version }}"
        dest: "{{ remote_base }}/current"
        state: link
        force: yes

    - name: Login to ECR
      shell: |
        aws ecr get-login-password --region {{ ecr_region }} | \
          docker login --username AWS --password-stdin {{ ecr_registry }}
      environment:
        AWS_DEFAULT_REGION: "{{ ecr_region }}"
      changed_when: false

    - name: Pull new images (before stopping services)
      shell: |
        cd {{ remote_base }}/current
        docker compose pull --quiet
      register: pull_result
      changed_when: false

    - name: Check if migrations service exists
      shell: |
        cd {{ remote_base }}/current
        docker compose --profile migrate config --services 2>/dev/null | grep -q "{{ service_name }}-migrate"
      register: has_migrations
      failed_when: false
      changed_when: false

    - name: Run database migrations (if applicable)
      shell: |
        cd {{ remote_base }}/current
        docker compose --profile migrate run --rm {{ service_name }}-migrate
      register: migrate_result
      when: has_migrations.rc == 0

    - name: Display migration output
      debug:
        msg: "{{ migrate_result.stdout_lines | default([]) }}"
      when: has_migrations.rc == 0 and migrate_result.stdout_lines is defined

    - name: Check if migrations failed
      fail:
        msg: "‚ùå Database migrations failed! Exit code: {{ migrate_result.rc }}"
      when:
        - has_migrations.rc == 0
        - migrate_result.rc is defined
        - migrate_result.rc != 0

    - name: Deploy service
      shell: |
        cd {{ remote_base }}/current
        docker compose up -d
      register: deploy_result

    - debug: var=deploy_result.stdout_lines

    - name: Wait for container to be healthy
      shell: |
        cd {{ remote_base }}/current
        docker compose ps {{ service_name }} --format json 2>/dev/null | jq -r '.State // empty' | head -1
      register: container_state
      until: container_state.stdout == "running" or container_state.stdout == "running (healthy)"
      retries: 12
      delay: 5
      failed_when: false

    - name: Get container logs if deployment failed
      shell: |
        cd {{ remote_base }}/current
        docker compose logs --tail=50 {{ service_name }}
      register: container_logs
      when: container_state.stdout != "running" and container_state.stdout != "running (healthy)"

    - name: Display container logs
      debug:
        msg: "{{ container_logs.stdout_lines }}"
      when: container_logs is defined and container_logs.stdout_lines is defined

    # ===== Ëá™Âä®ÂõûÊªöÈÄªËæë =====
    - name: Rollback to previous version on failure
      block:
        - name: Check if previous version directory exists
          stat:
            path: "{{ remote_base }}/{{ previous_version }}"
          register: previous_version_dir
          when: previous_version != ''

        - name: Check if rollback is possible
          set_fact:
            needs_rollback: "{{ (container_state.stdout != 'running' and container_state.stdout != 'running (healthy)') and previous_version != '' and previous_version_dir.stat.exists | default(false) }}"

        - name: Display rollback message
          debug:
            msg: "‚ö†Ô∏è Deployment failed! Rolling back to previous version: {{ previous_version }}"
          when: needs_rollback

        - name: Display no rollback available message
          debug:
            msg: "‚ùå Deployment failed and no previous version available to rollback to!"
          when: (container_state.stdout != 'running' and container_state.stdout != 'running (healthy)') and (previous_version == '' or not (previous_version_dir.stat.exists | default(false)))

        - name: Stop failed deployment
          shell: |
            cd {{ remote_base }}/current
            docker compose down
          when: needs_rollback
          failed_when: false

        - name: Restore previous version symlink
          file:
            src: "{{ remote_base }}/{{ previous_version }}"
            dest: "{{ remote_base }}/current"
            state: link
            force: yes
          when: needs_rollback

        - name: Start previous version
          shell: |
            cd {{ remote_base }}/current
            docker compose up -d
          when: needs_rollback
          register: rollback_result

        - name: Verify rollback succeeded
          shell: |
            cd {{ remote_base }}/current
            docker compose ps {{ service_name }} --format json 2>/dev/null | jq -r '.State // empty' | head -1
          register: rollback_state
          until: rollback_state.stdout == "running"
          retries: 3
          delay: 5
          when: needs_rollback
          failed_when: false

        - name: Display rollback result
          debug:
            msg: "‚úÖ Rollback completed. Service {{ service_name }} is running on version {{ previous_version }}"
          when: needs_rollback and rollback_state.stdout == "running"

        - name: Fail deployment after rollback
          fail:
            msg: "‚ùå Deployment of version {{ version }} failed! Rolled back to {{ previous_version }}. Check logs above."
          when: needs_rollback

        - name: Fail deployment without rollback (first deployment or no previous version)
          fail:
            msg: "‚ùå Deployment of version {{ version }} failed! No previous version to rollback to. Check logs above."
          when: (container_state.stdout != 'running' and container_state.stdout != 'running (healthy)') and not needs_rollback

    - name: Display success message
      debug:
        msg: "‚úÖ Successfully deployed {{ service_name }} version {{ version }}"
      when: container_state.stdout == "running" or container_state.stdout == "running (healthy)"

    - name: Keep only latest 3 versions
      shell: |
        cd {{ remote_base }}
        ls -t | grep -E '^[0-9]{14}$' | tail -n +4 | xargs -r rm -rf
